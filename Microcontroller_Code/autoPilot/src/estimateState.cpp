#include <Arduino.h>
#include <math.h>
#include <utils.h>
#include <estimateState.h>

stateEstimator::stateEstimator(wrapGPS &_myWrapGPS, wrapIMU &_myWrapIMU, wrapBarometer &_mywrapBarometer) : myWrapGPS(_myWrapGPS), myWrapIMU(_myWrapIMU), myWrapBarometer(_mywrapBarometer) {}

void stateEstimator::debug()
{
}

void stateEstimator::init()
{
  // State and Covariance
  xhat = {0, 0, 0, 0, 0, 0, 0, 0, 0, 1};
  P.Fill(0.0);
  for (int i = 1; i < Ns; i++)
  {
    P(i, i) = 100;
  }

  // THIS IS WRONG. FIX in MATLAB
  // G
  G.Fill(0.0);
  G(3, 0) = 1.0;
  G(4, 1) = 1.0;
  G(5, 2) = 1.0;
  G(6, 3) = 1.0;
  G(7, 4) = 1.0;
  G(8, 5) = 1.0;
}

// Helper funciton to convert LLA to ECEF
void stateEstimator::LatLonAlt2ECEF_Fcn(float Lat, float Lon, float Alt, Matrix<3> &r_ECEF)
{

  Lat = Lat * M_PI / 180.0;
  Lon = Lon * M_PI / 180.0;
  float a = 6378137.0;      // m
  float b = 6356752.314245; // m
  float cosLat = cos(Lat);
  float sinLat = sin(Lat);
  float cosLon = cos(Lon);
  float sinLon = sin(Lon);
  float a2 = a * a;
  float denom = sqrt(a * a * cosLat * cosLat + b * b * sinLat * sinLat);
  float N = a2 / denom;

  r_ECEF = {(N + Alt) * cosLat * cosLon,
            (N + Alt) * cosLat * sinLon,
            ((b * b) * N / (a * a) + Alt) * sinLat};
}

// THIS MAY OR MAY NOT BE NONSENSE. REMAINS TO BE SEEN
void stateEstimator::LatLonAlt2NED_Fcn(float Lat, float Lon, float Alt, Matrix<3> &r_NED)
{
  Matrix<3> r_ECEF;
  LatLonAlt2ECEF_Fcn(Lat, Lon, Alt, r_ECEF);
  r_NED = NED_C_ECEF * (r_ECEF - r0_ECEF);
}

void stateEstimator::setAngle2Range(float &angle)
{

  if (angle > M_PI)
  {
    angle = angle - 2.0 * M_PI;
  }
}

// Generate Measurement Vector at a point in time
void stateEstimator::getMeasurementVector(Matrix<9> &Z, Matrix<6> &Z_input)
{
  // --- Z_inputs --- //

  // Acceleration
  Z_input(0) = myWrapIMU.getaccX() * 1E-3 * 9.81;
  Z_input(1) = myWrapIMU.getaccY() * 1E-3 * 9.81 * -1;
  Z_input(2) = myWrapIMU.getaccZ() * 1E-3 * 9.81 * -1;

  // Gyro
  Z_input(3) = myWrapIMU.getgyrX() * M_PI / 180;
  Z_input(4) = myWrapIMU.getgyrY() * M_PI / 180 * -1;
  Z_input(5) = myWrapIMU.getgyrZ() * M_PI / 180 * -1;

  // --- Z --- //

  // GPS Position
  float Lat = myWrapGPS.getLatitude() * 1E-7;
  float Lon = myWrapGPS.getLongitude() * 1E-7;
  float Alt = myWrapGPS.getAltitude() * 1E-3;

  Matrix<3> r_NED;
  LatLonAlt2NED_Fcn(Lat, Lon, Alt, r_NED);
  Z(0) = r_NED(0);
  Z(1) = r_NED(1);
  Z(2) = r_NED(2);

  // GPS Speed
  Z(3) = myWrapGPS.getGroundSpeed();

  // Magnetometer
  Z(4) = myWrapIMU.getmagX();
  Z(5) = myWrapIMU.getmagY();
  Z(6) = myWrapIMU.getmagZ();

  // Heading
  float Heading = myWrapGPS.getHeading() * 1E-5 * M_PI / 180;
  setAngle2Range(Heading);
  Z(7) = Heading;

  // Altitude
  float pressure = myWrapBarometer.getPressure();
  float delAlt = (pressure - p0) * dhdp;
  Z(8) = -delAlt;
}

// Helper function to generate transformation matrix from ECEF to NED
void stateEstimator::TECEF2NED_Fcn(Matrix<3> &r_ECEF)
{
  float phi = asin(r_ECEF(2) / norm3(r_ECEF));
  float lambda = atan2(r_ECEF(1), r_ECEF(0));

  NED_C_ECEF = {-sin(phi) * cos(lambda), -sin(lambda), -cos(phi) * cos(lambda),
                -sin(phi) * sin(lambda), cos(lambda), -cos(phi) * sin(lambda),
                cos(phi), 0, -sin(phi)};
}

// Continuous Dynamics Function
void stateEstimator::f_Fcn(Matrix<Ns> &xhat, Matrix<6> &uk, Matrix<Ns> &fdot)
{
  float t2;
  float t3;
  float t4;
  float t5;
  float t6;
  float t7_tmp;
  float t7;
  float t8_tmp;
  float t8;
  float t9_tmp;
  float t9;
  float t10_tmp;
  float t10;
  float t11;

  // F_FCN
  //     F = F_FCN(T,xhat,uk)
  //     This function was generated by the Symbolic Math Toolbox version 8.5.
  //     16-Aug-2021 15:17:55
  t2 = xhat(6) * xhat(6);
  t3 = xhat(7) * xhat(7);
  t4 = xhat(8) * xhat(8);
  t5 = xhat(9) * xhat(9);
  t6 = xhat(6) * xhat(7) * 2.0;
  t7_tmp = xhat(6) * xhat(8);
  t7 = t7_tmp * 2.0;
  t8_tmp = xhat(6) * xhat(9);
  t8 = t8_tmp * 2.0;
  t9_tmp = xhat(7) * xhat(8);
  t9 = t9_tmp * 2.0;
  t10_tmp = xhat(7) * xhat(9);
  t10 = t10_tmp * 2.0;
  t11 = xhat(8) * xhat(9) * 2.0;
  fdot(0) = (xhat(3) * (((t2 + t5) + -t3) + -t4) + xhat(5) * (t7 + t10)) + xhat(4) *
                                                                               (t6 - t11);
  fdot(1) = (-xhat(4) * (((t2 + t4) + -t3) + -t5) + xhat(3) * (t6 + t11)) - xhat(5) *
                                                                                (t8 - t9);
  fdot(2) = (-xhat(5) * (((t2 + t3) + -t4) + -t5) + xhat(4) * (t8 + t9)) + xhat(3) *
                                                                               (t7 - t10);
  fdot(3) = (uk(0) + t7_tmp * 19.6) - t10_tmp * 19.6;
  fdot(4) = (uk(1) + t8_tmp * 19.6) + t9_tmp * 19.6;
  fdot(5) = (((uk(2) - t2 * 9.8) - t3 * 9.8) + t4 * 9.8) + t5 * 9.8;
  fdot(6) = (uk(3) * xhat(9) / 2.0 - uk(4) * xhat(8) / 2.0) + xhat(7) * uk(5) / 2.0;
  fdot(7) = (uk(3) * xhat(8) / 2.0 + uk(4) * xhat(9) / 2.0) - xhat(6) * uk(5) / 2.0;
  fdot(8) = (uk(3) * xhat(7) * -0.5 + uk(4) * xhat(6) / 2.0) + xhat(9) * uk(5) /
                                                                   2.0;
  fdot(9) = (uk(3) * xhat(6) * -0.5 - uk(4) * xhat(7) / 2.0) - xhat(8) * uk(5) /
                                                                   2.0;
}

// Continuous F Function
void stateEstimator::get_F_jac(Matrix<Ns> &xhat, Matrix<6> &uk, Matrix<Ns, Ns> &F_jac)
{

  F_jac.Fill(0.0);
  F_jac(0, 3) = xhat(6) * xhat(6) - xhat(7) * xhat(7) - xhat(8) * xhat(8) + xhat(9) * xhat(9);
  F_jac(0, 4) = xhat(6) * xhat(7) * 2.0 - xhat(8) * xhat(9) * 2.0;
  F_jac(0, 5) = xhat(6) * xhat(8) * 2.0 + xhat(7) * xhat(9) * 2.0;
  F_jac(0, 6) = xhat(6) * xhat(3) * 2.0 + xhat(7) * xhat(4) * 2.0 + xhat(8) * xhat(5) * 2.0;
  F_jac(0, 7) = xhat(7) * xhat(3) * -2.0 + xhat(6) * xhat(4) * 2.0 + xhat(9) * xhat(5) * 2.0;
  F_jac(0, 8) = xhat(8) * xhat(3) * -2.0 - xhat(9) * xhat(4) * 2.0 + xhat(6) * xhat(5) * 2.0;
  F_jac(0, 9) = xhat(9) * xhat(3) * 2.0 - xhat(8) * xhat(4) * 2.0 + xhat(7) * xhat(5) * 2.0;
  F_jac(1, 3) = xhat(6) * xhat(7) * 2.0 + xhat(8) * xhat(9) * 2.0;
  F_jac(1, 4) = -xhat(6) * xhat(6) + xhat(7) * xhat(7) - xhat(8) * xhat(8) + xhat(9) * xhat(9);
  F_jac(1, 5) = xhat(6) * xhat(9) * -2.0 + xhat(7) * xhat(8) * 2.0;
  F_jac(1, 6) = xhat(7) * xhat(3) * 2.0 - xhat(6) * xhat(4) * 2.0 - xhat(9) * xhat(5) * 2.0;
  F_jac(1, 7) = xhat(6) * xhat(3) * 2.0 + xhat(7) * xhat(4) * 2.0 + xhat(8) * xhat(5) * 2.0;
  F_jac(1, 8) = xhat(9) * xhat(3) * 2.0 - xhat(8) * xhat(4) * 2.0 + xhat(7) * xhat(5) * 2.0;
  F_jac(1, 9) = xhat(8) * xhat(3) * 2.0 + xhat(9) * xhat(4) * 2.0 - xhat(6) * xhat(5) * 2.0;
  F_jac(2, 3) = xhat(6) * xhat(8) * 2.0 - xhat(7) * xhat(9) * 2.0;
  F_jac(2, 4) = xhat(6) * xhat(9) * 2.0 + xhat(7) * xhat(8) * 2.0;
  F_jac(2, 5) = -xhat(6) * xhat(6) - xhat(7) * xhat(7) + xhat(8) * xhat(8) + xhat(9) * xhat(9);
  F_jac(2, 6) = xhat(8) * xhat(3) * 2.0 + xhat(9) * xhat(4) * 2.0 - xhat(6) * xhat(5) * 2.0;
  F_jac(2, 7) = xhat(9) * xhat(3) * -2.0 + xhat(8) * xhat(4) * 2.0 - xhat(7) * xhat(5) * 2.0;
  F_jac(2, 8) = xhat(6) * xhat(3) * 2.0 + xhat(7) * xhat(4) * 2.0 + xhat(8) * xhat(5) * 2.0;
  F_jac(2, 9) = xhat(7) * xhat(3) * -2.0 + xhat(6) * xhat(4) * 2.0 + xhat(9) * xhat(5) * 2.0;
  F_jac(3, 6) = xhat(8) * (9.8E+1 / 5.0);
  F_jac(3, 7) = xhat(9) * (-9.8E+1 / 5.0);
  F_jac(3, 8) = xhat(6) * (9.8E+1 / 5.0);
  F_jac(3, 9) = xhat(7) * (-9.8E+1 / 5.0);
  F_jac(4, 6) = xhat(9) * (9.8E+1 / 5.0);
  F_jac(4, 7) = xhat(8) * (9.8E+1 / 5.0);
  F_jac(4, 8) = xhat(7) * (9.8E+1 / 5.0);
  F_jac(4, 9) = xhat(6) * (9.8E+1 / 5.0);
  F_jac(5, 6) = xhat(6) * (-9.8E+1 / 5.0);
  F_jac(5, 7) = xhat(7) * (-9.8E+1 / 5.0);
  F_jac(5, 8) = xhat(8) * (9.8E+1 / 5.0);
  F_jac(5, 9) = xhat(9) * (9.8E+1 / 5.0);
  F_jac(6, 7) = uk(5) / 2.0;
  F_jac(6, 8) = uk(4) * (-1.0 / 2.0);
  F_jac(6, 9) = uk(3) / 2.0;
  F_jac(7, 6) = uk(5) * (-1.0 / 2.0);
  F_jac(7, 8) = uk(3) / 2.0;
  F_jac(7, 9) = uk(4) / 2.0;
  F_jac(8, 6) = uk(4) / 2.0;
  F_jac(8, 7) = uk(3) * (-1.0 / 2.0);
  F_jac(8, 9) = uk(5) / 2.0;
  F_jac(9, 6) = uk(3) * (-1.0 / 2.0);
  F_jac(9, 7) = uk(4) * (-1.0 / 2.0);
  F_jac(9, 8) = uk(5) * (-1.0 / 2.0);
}

void stateEstimator::get_Q(float dT, Matrix<6, 6> &Q)
{
  Q.Fill(0.0);
  Q(0, 0) = pow(dT * 8.055656553821564E-2 + 2.236262379681608, 2.0);
  Q(1, 1) = pow(dT * 8.602270870712547E-2 + 1.313070372031577, 2.0);
  Q(2, 2) = pow(dT * 2.831314927881532E-1 + 4.820209694184105, 2.0);
  Q(3, 3) = pow(dT * 3.985940620834597E-3 - 1.126812513616809E-2, 2.0);
  Q(4, 4) = pow(dT * 3.401197824382432E-3 - 1.311015844382992E-2, 2.0);
  Q(5, 5) = pow(dT * 2.00959903402234E-3 - 1.447906471632683E-2, 2.0);
}

void stateEstimator::get_H_jac(Matrix<Ns> &xhat, Matrix<9, Ns> &H_jac)
{
  H_jac.Fill(0.0);
  float t2 = fabs(xhat(3));
  float t3 = fabs(xhat(4));
  float t4 = fabs(xhat(5));
  float t5 = xhat(6) * xhat(6);
  float t6 = xhat(7) * xhat(7);
  float t7 = xhat(8) * xhat(8);
  float t8 = xhat(9) * xhat(9);
  float t12 = xhat(6) * xhat(7) * 2.0;
  float t13 = xhat(6) * xhat(8) * 2.0;
  float t14 = xhat(6) * xhat(9) * 2.0;
  float t15 = xhat(7) * xhat(8) * 2.0;
  float t16 = xhat(7) * xhat(9) * 2.0;
  float t17 = xhat(8) * xhat(9) * 2.0;
  float t18 = xhat(6) * xhat(3) * 2.0;
  float t19 = xhat(7) * xhat(3) * 2.0;
  float t20 = xhat(8) * xhat(3) * 2.0;
  float t21 = xhat(9) * xhat(3) * 2.0;
  float t22 = xhat(6) * xhat(4) * 2.0;
  float t23 = xhat(7) * xhat(4) * 2.0;
  float t24 = xhat(8) * xhat(4) * 2.0;
  float t25 = xhat(9) * xhat(4) * 2.0;
  float t26 = xhat(6) * xhat(5) * 2.0;
  float t27 = xhat(7) * xhat(5) * 2.0;
  float t28 = xhat(8) * xhat(5) * 2.0;
  float t29 = xhat(9) * xhat(5) * 2.0;
  float t57 = xhat(6) * 1.06871028374007E+2;
  float t58 = xhat(7) * 1.06871028374007E+2;
  float t59 = xhat(8) * 1.06871028374007E+2;
  float t60 = xhat(9) * 1.06871028374007E+2;
  float t62 = xhat(6) * 2.363521905321952E+1;
  float t63 = xhat(7) * 2.363521905321952E+1;
  float t64 = xhat(8) * 2.363521905321952E+1;
  float t65 = xhat(9) * 2.363521905321952E+1;
  float t66 = xhat(6) * 6.117036165833703;
  float t67 = xhat(7) * 6.117036165833703;
  float t68 = xhat(8) * 6.117036165833703;
  float t69 = xhat(9) * 6.117036165833703;
  float t9 = t2 * t2;
  float t10 = t3 * t3;
  float t11 = t4 * t4;
  float t30 = -t15;
  float t31 = -t17;
  float t32 = -t19;
  float t33 = -t24;
  float t34 = -t26;
  float t35 = -t6;
  float t36 = -t7;
  float t37 = -t8;
  float t38 = t12 + t17;
  float t39 = t13 + t16;
  float t47 = t18 + t23 + t28;
  float t61 = -t58;
  float t70 = -t64;
  float t71 = -t67;
  float t72 = -t68;
  float t73 = -t69;
  float t82 = t60 + t63 + t66;
  float t40 = t12 + t31;
  float t41 = t14 + t30;
  float t42 = t38 * xhat(3);
  float t43 = t39 * xhat(5);
  float t46 = t9 + t10 + t11;
  float t49 = t22 + t29 + t32;
  float t50 = t20 + t25 + t34;
  float t51 = t21 + t27 + t33;
  float t53 = t5 + t8 + t35 + t36;
  float t54 = t5 + t7 + t35 + t37;
  float t83 = t59 + t62 + t71;
  float t84 = t57 + t70 + t73;
  float t85 = t61 + t65 + t72;
  float t44 = t40 * xhat(4);
  float t45 = t41 * xhat(5);
  float t48 = -t42;
  float t52 = 1.0 / sqrt(t46);
  float t55 = t53 * xhat(3);
  float t56 = t54 * xhat(4);
  float t74 = t43 + t44 + t55;
  float t75 = t45 + t48 + t56;
  float t76 = t74 * t74;
  float t77 = 1.0 / t74;
  float t79 = t75 * t75;
  float t78 = 1.0 / t76;
  float t80 = t76 + t79;
  float t81 = 1.0 / t80;
  H_jac(0, 0) = 1.0;
  H_jac(1, 1) = 1.0;
  H_jac(2, 2) = 1.0;
  H_jac(3, 3) = t2 * t52 * ((xhat(3) / fabs(xhat(3))));
  H_jac(3, 4) = t3 * t52 * ((xhat(4) / fabs(xhat(4))));
  H_jac(3, 5) = t4 * t52 * ((xhat(5) / fabs(xhat(5))));
  H_jac(4, 6) = t83;
  H_jac(4, 7) = -t82;
  H_jac(4, 8) = t84;
  H_jac(4, 9) = t85;
  H_jac(5, 6) = t82;
  H_jac(5, 7) = t83;
  H_jac(5, 8) = t58 - t65 + t68;
  H_jac(5, 9) = t84;
  H_jac(6, 6) = -t57 + t64 + t69;
  H_jac(6, 7) = t85;
  H_jac(6, 8) = t83;
  H_jac(6, 9) = t82;
  H_jac(7, 3) = t76 * t81 * (t38 * t77 + t53 * t75 * t78);
  H_jac(7, 4) = -t76 * t81 * (t54 * t77 - t40 * t75 * t78);
  H_jac(7, 5) = -t76 * t81 * (t41 * t77 - t39 * t75 * t78);
  H_jac(7, 6) = -t76 * t81 * (t49 * t77 - t47 * t75 * t78);
  H_jac(7, 7) = t76 * t81 * (t47 * t77 + t49 * t75 * t78);
  H_jac(7, 8) = t76 * t81 * (t51 * t77 - t50 * t75 * t78);
  H_jac(7, 9) = t76 * t81 * (t50 * t77 + t51 * t75 * t78);
  H_jac(8, 2) = 1.0;
}

void stateEstimator::get_R(float dT, Matrix<9, 9> &R)
{
  R.Fill(0.0);
  R(0, 0) = 2.5E+1 / 2.0;
  R(1, 1) = 2.5E+1 / 2.0;
  R(2, 2) = 1.0E+2;
  R(3, 3) = 1.0 / 4.0E+2;
  R(4, 4) = pow(dT * 4.698552240547276E-3 + 6.495281709453083E-1, 2.0);
  R(5, 5) = pow(dT * 1.373789489995686E-3 + 7.878470583458638E-1, 2.0);
  R(6, 6) = pow(dT * 2.990748419728659E-3 + 6.606739589323193E-1, 2.0);
  R(7, 7) = (3.141592653589793 * 3.141592653589793) / 3.6E+3;
  R(8, 8) = 4.0E-4;
}

void stateEstimator::h_fcn(Matrix<Ns> &xhat, Matrix<Nm> &h)
{
  float t2 = xhat(6) * xhat(6);
  float t3 = xhat(7) * xhat(7);
  float t4 = xhat(8) * xhat(8);
  float t5 = xhat(9) * xhat(9);
  float t6 = xhat(6) * xhat(7) * 2.0;
  float t7 = xhat(8) * xhat(9) * 2.0;
  float t8 = -t3;
  h(0, 0) = xhat(0);
  h(1, 0) = xhat(1);
  h(2, 0) = xhat(2);
  h(3, 0) = sqrt(pow(fabs(xhat(3)), 2.0) + pow(fabs(xhat(4)), 2.0) + pow(fabs(xhat(5)), 2.0));
  h(4, 0) = t2 * 1.181760952660976E+1 - t3 * 1.181760952660976E+1 - t4 * 1.181760952660976E+1 + t5 * 1.181760952660976E+1 - xhat(6) * xhat(7) * 6.117036165833703 + xhat(6) * xhat(8) * 1.06871028374007E+2 - xhat(7) * xhat(9) * 1.06871028374007E+2 - xhat(8) * xhat(9) * 6.117036165833703;
  h(5, 0) = t2 * 3.058518082916851 - t3 * 3.058518082916851 + t4 * 3.058518082916851 - t5 * 3.058518082916851 + xhat(6) * xhat(7) * 2.363521905321952E+1 + xhat(6) * xhat(9) * 1.06871028374007E+2 + xhat(7) * xhat(8) * 1.06871028374007E+2 - xhat(8) * xhat(9) * 2.363521905321952E+1;
  h(6, 0) = t2 * (-5.343551418700349E+1) - t3 * 5.343551418700349E+1 + t4 * 5.343551418700349E+1 + t5 * 5.343551418700349E+1 + xhat(6) * xhat(8) * 2.363521905321952E+1 + xhat(6) * xhat(9) * 6.117036165833703 - xhat(7) * xhat(8) * 6.117036165833703 + xhat(7) * xhat(9) * 2.363521905321952E+1;
  h(7, 0) = atan2(xhat(3) * (t6 + t7) - xhat(4) * (t2 + t4 - t5 + t8) - xhat(5) * (xhat(6) * xhat(9) * 2.0 - xhat(7) * xhat(8) * 2.0), xhat(3) * (t2 - t4 + t5 + t8) + xhat(4) * (t6 - t7) + xhat(5) * (xhat(6) * xhat(8) * 2.0 + xhat(7) * xhat(9) * 2.0));
  h(8, 0) = xhat(2);
}

// Predict State
void stateEstimator::predictState(float delt, Matrix<Ns> &xhat, Matrix<6> &uk)
{
  Matrix<Ns> fdot;
  f_Fcn(xhat, uk, fdot);

  for (int i = 0; i < Ns; i++)
  {
    xhat(i) = xhat(i) + delt * fdot(i);
  }
}

// Sets up R0ECEF and NED_C_ECEF using the first GPS measurement
void stateEstimator::setupR0ECEF()
{
  bool initialized = false;
  Serial.print("Setting up r0_ECEF ... ");
  while (!initialized)
  // while (0) // this is jank delete it
  {
    myWrapGPS.update();
    int SIV = myWrapGPS.getSIV();

    if (SIV > 2)
    {
      initialized = 1;
      Serial.print(SIV);
      Serial.println(" Sats in view. Success!");
    }
    else
    {
      Serial.print(SIV);
      Serial.println(" Sats in view. Failed.");
      Serial.print("Retrying...");
      delay(500);
    }
  }

  float Lat = myWrapGPS.getLatitude() * 1E-7;
  float Lon = myWrapGPS.getLongitude() * 1E-7;
  float Alt = myWrapGPS.getAltitude() * 1E-3;
  LatLonAlt2ECEF_Fcn(Lat, Lon, Alt, r0_ECEF);
  TECEF2NED_Fcn(r0_ECEF);
}

void stateEstimator::setupP0()
{
  bool initialized = false;
  float pressure;
  Serial.print("Setting up p0...");
  while (!initialized)
  {
    myWrapBarometer.update();
    pressure = myWrapBarometer.getPressure();

    if (pressure != -1)
    {
      initialized = 1;
      Serial.println(" Success!");
    }
    else
    {
      delay(50);
    }
  }

  dhdp = (-1.0 / 1.2E-4) * 1.0 / pressure;
  alt0 = (-1.0 / 1.2E-4) * log(pressure / 1013.25);
  p0 = pressure;
}

// --- estimateState --- //
Matrix<Ns> stateEstimator::step(float delt)
{

  // Get Measurement vector
  Matrix<9> Z;
  Matrix<6> Z_input;
  getMeasurementVector(Z, Z_input);

  // Z_input.Fill(0.001);
  // Z_input(2) = -9.81;
  // Predict State
  predictState(delt, xhat, Z_input); // xhatkp1_p

  // Normalize Quaternion
  auto quat = xhat.Submatrix<4, 1>(6, 1);
  float quatMag = sqrt(quat(0) * quat(0) + quat(1) * quat(1) + quat(2) * quat(2) + quat(3) * quat(3));
  for (int i = 0; i < quat.Rows; i++)
  {
    quat(i) = quat(i) / quatMag;
  }

  // Predict Covariance
  Matrix<Ns, Ns> F_jac;
  get_F_jac(xhat, Z_input, F_jac);
  Matrix<6, 6> Q;
  get_Q(90.0, Q);
  Matrix<Ns, Ns> deltI;
  deltI.Fill(0.0);
  float delt2 = delt * delt;
  for (int i = 0; i < Ns; i++)
  {
    deltI(i, i) = delt2;
  }

  P = F_jac * P * (~F_jac) + G * Q * (~G) * deltI;

  // Kalman Gain
  Matrix<9, Ns> H_jac;
  get_H_jac(xhat, H_jac);
  Matrix<9, 9> R;
  get_R(90, R);

  Matrix<Nm, Nm> invDenom = H_jac * P * (~H_jac) + R;
  Invert(invDenom);

  Matrix<Ns, Nm> K = P * (~H_jac) * invDenom;

  float heading = Z(8);

  setAngle2Range(heading);
  Z(8) = heading;

  Matrix<Nm> h;
  h_fcn(xhat, h);

  Matrix<Nm> res = Z - h;

  // Update Step
  xhat = xhat + K * res; // xhatkp1_u

  Matrix<Ns, Ns> Is;
  Is.Fill(0.0);
  for (int i = 0; i < Ns; i++)
  {
    Is(i, i) = 1.0;
  }

  Matrix<Ns, Ns> ImKH = (Is - K * H_jac);
  // P = ImKH * P * (~ImKH)  + K * R * (~K);
  // Matrix<Ns, Ns> Left = ImKH * P;
  Matrix<Ns, Ns> Full = P * (~ImKH);
  // Matrix<Ns, Ns> Ofull = P * (~ImKH);
  Serial << Full << '\n';
  return xhat;


  // It appears that this runs out of memory on this last fcn. Next step is to seperate some of these fcns so that memory is freed up
}