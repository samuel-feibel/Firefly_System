#include <Arduino.h>

#include <estimateState.h>
#include <IMU.h>
#include <GPS.h>
#include <barometer.h>
#include <math.h>
#include <utils.h>

double r0_ECEF[3];
double NED_C_ECEF[9];
double dhdp;
double alt0;
double p0;

// THIS MAY OR MAY NOT BE NONSENSE. REMAINS TO BE SEEN
static void LatLonAlt2NED_Fcn(double Lat, double Lon, double Alt, double r0_ECEF[3], double NED_C_ECEF[9], double *r_NED)
{
  double t4;
  double t7;
  double t9;
  double t17;
  double t15;
  double t22;

  // LATLONALT2NED_FCN
  //     R_NED = LATLONALT2NED_FCN(LAT,LON,ALT,r0_ECEF,NED_C_ECEF)
  //     This function was generated by the Symbolic Math Toolbox version 8.5.
  //     10-Jun-2021 23:09:47
  t4 = cos(Lat * M_PI / 180.0);
  t7 = Lon * 9.869604401089358 / 32400.0;
  t9 = sin(Lat * 9.869604401089358 / 32400.0);
  t17 = t4 * t4 * 4.0680631590769E+13 + t9 * t9 * 4.0408299984659156E+13;

  t17 = sqrt(t17);
  t15 = 1.0 / t17;
  t17 = Alt + t15 * 4.0680631590769E+13;
  t22 = r0_ECEF[0] + -(t4 * cos(t7) * t17);
  t4 = r0_ECEF[1] + -(t4 * sin(t7) * t17);
  t17 = r0_ECEF[2] + -(t9 * (Alt + t15 * 4.0408299984659148E+13));
  r_NED[0] = (-NED_C_ECEF[0] * t22 - NED_C_ECEF[3] * t4) - NED_C_ECEF[6] * t17;
  r_NED[1] = (-NED_C_ECEF[1] * t22 - NED_C_ECEF[4] * t4) - NED_C_ECEF[7] * t17;
  r_NED[2] = (-NED_C_ECEF[2] * t22 - NED_C_ECEF[5] * t4) - NED_C_ECEF[8] * t17;
}

static void setAngle2Range(double *angle)
{
  
  if (*angle > M_PI)
  {
    *angle = *angle - 2.0 * M_PI;
  }
}

// Generate Measurement Vector at a point in time
static void getMeasurementVector(double *Z, double *Z_input)
{
  // --- Z_inputs --- //

  // Acceleration
  Z_input[0] = getIMUaccX() * 1E-3 * 9.81;
  Z_input[1] = getIMUaccY() * 1E-3 * 9.81 * -1;
  Z_input[2] = getIMUaccZ() * 1E-3 * 9.81 * -1;

  // Gyro
  Z_input[4] = getIMUgyrX() * M_PI / 180;
  Z_input[5] = getIMUgyrY() * M_PI / 180 * -1;
  Z_input[6] = getIMUgyrZ() * M_PI / 180 * -1;

  // --- Z --- //

  // GPS Position
  double Lat = getGPSLatitude() * 1E-7;
  double Lon = getGPSLongitude() * 1E-7;
  double Alt = getGPSAltitude() * 1E-3;
  double r_NED[3];
  LatLonAlt2NED_Fcn(Lat, Lon, Alt, r0_ECEF, NED_C_ECEF, &r_NED[0]);
  Z[0] = r_NED[0];
  Z[1] = r_NED[1];
  Z[2] = r_NED[2];

  // GPS Speed
  Z[3] = getGPSGroundSpeed();

  // Magnetometer
  Z[4] = getIMUmagX();
  Z[5] = getIMUmagY();
  Z[6] = getIMUmagZ();

  // Heading
  double Heading = getGPSHeading() * 1E-5 * M_PI / 180;
  setAngle2Range(&Heading);
  Z[7] = Heading;

  // Altitude
  double pressure = getPressure();
  double delAlt = (pressure - p0) * dhdp;
  Z[8] = -delAlt;

}

// Helper funciton to convert LLA to ECEF
static void LatLonAlt2ECEF_Fcn(double Lat, double Lon, double Alt, double *r_ECEF)
{
  double t2;
  double t3;
  double t4;
  double t5;
  double t11;

  // LATLONALT2ECEF_FCN
  //     R0_ECEF = LATLONALT2ECEF_FCN(LAT,LON,ALT)
  //     This function was generated by the Symbolic Math Toolbox version 8.5.
  //     10-Jun-2021 23:09:53
  t2 = Lat * 3.1415926535897931 / 180.0;
  t3 = Lon * 3.1415926535897931 / 180.0;
  t4 = cos(t2);
  t5 = sin(t2);
  t2 = t4 * t4 * 4.0680631590769E+13 + t5 * t5 * 4.0408299984659156E+13;

  t2 = sqrt(t2);
  t11 = 1.0 / t2;
  t2 = t4 * (Alt + t11 * 4.0680631590769E+13);
  r_ECEF[0] = t2 * cos(t3);
  r_ECEF[1] = t2 * sin(t3);
  r_ECEF[2] = t5 * (Alt + t11 * 4.0408299984659148E+13);
}

// Helper function to generate transformation matrix from ECEF to NED
static void TECEF2NED_Fcn(double r_ECEF[3], double *NED_C_ECEF)
{
  double a;
  double t15;
  double b_a;
  double t13;
  double t12;

  // TECEF2NED_FCN
  //     NED_C_ECEF = TECEF2NED_FCN(r_ECEF)
  //     This function was generated by the Symbolic Math Toolbox version 8.5.
  //     11-Jun-2021 19:40:44
  a = fabs(r_ECEF[0]);
  t15 = fabs(r_ECEF[1]);
  b_a = fabs(r_ECEF[2]);
  t13 = r_ECEF[0] * r_ECEF[0] + r_ECEF[1] * r_ECEF[1];

  t13 = sqrt(t13);
  t12 = 1.0 / t13;
  t13 = (a * a + t15 * t15) + b_a * b_a;
  t15 = 1.0 / sqrt(t13);
  t13 = -(r_ECEF[2] * r_ECEF[2] * (1.0 / t13));

  t13 = sqrt(t13 + 1.0);
  NED_C_ECEF[0] = -r_ECEF[0] * r_ECEF[2] * t12 * t15;
  a = -r_ECEF[1] * t12;
  NED_C_ECEF[1] = a;
  NED_C_ECEF[2] = -r_ECEF[0] * t12 * t13;
  NED_C_ECEF[3] = -r_ECEF[1] * r_ECEF[2] * t12 * t15;
  NED_C_ECEF[4] = r_ECEF[0] * t12;
  NED_C_ECEF[5] = a * t13;
  NED_C_ECEF[6] = t13;
  NED_C_ECEF[7] = 0.0;
  NED_C_ECEF[8] = -r_ECEF[2] * t15;
}

// Continuous Dynamics Function
static void f_Fcn(double *xhatk_u, double *uk, double *fdot)
{
  double t2;
  double t3;
  double t4;
  double t5;
  double t6;
  double t7_tmp;
  double t7;
  double t8_tmp;
  double t8;
  double t9_tmp;
  double t9;
  double t10_tmp;
  double t10;
  double t11;

  // F_FCN
  //     F = F_FCN(T,xhatk_u,uk)
  //     This function was generated by the Symbolic Math Toolbox version 8.5.
  //     16-Aug-2021 15:17:55
  t2 = xhatk_u[6] * xhatk_u[6];
  t3 = xhatk_u[7] * xhatk_u[7];
  t4 = xhatk_u[8] * xhatk_u[8];
  t5 = xhatk_u[9] * xhatk_u[9];
  t6 = xhatk_u[6] * xhatk_u[7] * 2.0;
  t7_tmp = xhatk_u[6] * xhatk_u[8];
  t7 = t7_tmp * 2.0;
  t8_tmp = xhatk_u[6] * xhatk_u[9];
  t8 = t8_tmp * 2.0;
  t9_tmp = xhatk_u[7] * xhatk_u[8];
  t9 = t9_tmp * 2.0;
  t10_tmp = xhatk_u[7] * xhatk_u[9];
  t10 = t10_tmp * 2.0;
  t11 = xhatk_u[8] * xhatk_u[9] * 2.0;
  fdot[0] = (xhatk_u[3] * (((t2 + t5) + -t3) + -t4) + xhatk_u[5] * (t7 + t10)) + xhatk_u[4] *
    (t6 - t11);
  fdot[1] = (-xhatk_u[4] * (((t2 + t4) + -t3) + -t5) + xhatk_u[3] * (t6 + t11)) - xhatk_u[5] *
    (t8 - t9);
  fdot[2] = (-xhatk_u[5] * (((t2 + t3) + -t4) + -t5) + xhatk_u[4] * (t8 + t9)) + xhatk_u[3] *
    (t7 - t10);
  fdot[3] = (uk[0] + t7_tmp * 19.6) - t10_tmp * 19.6;
  fdot[4] = (uk[1] + t8_tmp * 19.6) + t9_tmp * 19.6;
  fdot[5] = (((uk[2] - t2 * 9.8) - t3 * 9.8) + t4 * 9.8) + t5 * 9.8;
  fdot[6] = (uk[3] * xhatk_u[9] / 2.0 - uk[4] * xhatk_u[8] / 2.0) + xhatk_u[7] * uk[5] / 2.0;
  fdot[7] = (uk[3] * xhatk_u[8] / 2.0 + uk[4] * xhatk_u[9] / 2.0) - xhatk_u[6] * uk[5] / 2.0;
  fdot[8] = (uk[3] * xhatk_u[7] * -0.5 + uk[4] * xhatk_u[6] / 2.0) + xhatk_u[9] * uk[5] /
    2.0;
  fdot[9] = (uk[3] * xhatk_u[6] * -0.5 - uk[4] * xhatk_u[7] / 2.0) - xhatk_u[8] * uk[5] /
    2.0;
}

// Predict State
static void predictState(double delt, double *xhatk_u, double *uk, double *xhatkp1_p) {
  double fdot[10];
  f_Fcn(&xhatk_u[0], &uk[0], &fdot[0]);

  for (int i = 0; i<10; i++){
    xhatkp1_p[i] = xhatk_u[i] + delt * fdot[i];
  }

}

// Sets up R0ECEF and NED_C_ECEF using the first GPS measurement
void setupR0ECEF()
{
  bool initialized = false;
  Serial.print("Setting up r0_ECEF ... ");
  while (!initialized)
  // while (0) // this is jank delete it
  {
    updateGPS();
    int SIV = getGPSSIV();

    if (SIV > 2)
    {
      initialized = 1;
      Serial.print(SIV);
      Serial.println(" Sats in view. Success!");
    }
    else
    {
      Serial.print(SIV);
      Serial.println(" Sats in view. Failed.");
      Serial.print("Retrying...");
      delay(500);
    }
  }

  double Lat = getGPSLatitude() * 1E-7;
  double Lon = getGPSLongitude() * 1E-7;
  double Alt = getGPSAltitude() * 1E-3;
  LatLonAlt2ECEF_Fcn(Lat, Lon, Alt, &r0_ECEF[0]);
  TECEF2NED_Fcn(r0_ECEF, &NED_C_ECEF[0]);
}

void setupP0()
{
  bool initialized = false;
  double pressure;
  Serial.print("Setting up p0...");
  while (!initialized)
  {
    updateBarometer();
    pressure = getPressure();

    if (pressure != -1)
    {
      initialized = 1;
      Serial.println(" Success!");
    }
    else
    {
      delay(50);
    }
  }

  dhdp = (-1.0 / 1.2E-4) * 1.0 / pressure;
  alt0 = (-1.0 / 1.2E-4) * log(pressure / 1013.25);
  p0 = pressure;
}

// --- estimateState --- //
void estimateState(double *xhatk_u, double delt)
{
  
  // Get Measurement vector
  static double Z[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
  static double Z_input[6] = {0, 0, 0, 0, 0, 0};
  getMeasurementVector(&Z[0], &Z_input[0]);

  // Serial.println("Measurement Vector:");
  // printArray(&Z[0],9);

  // Predict State
  double xhatkp1_p[10];
  predictState(delt,&xhatk_u[0],&Z_input[0], &xhatkp1_p[0]);

  // Normalize Quaternion
  double quatMag = sqrt(xhatkp1_p[6]*xhatkp1_p[6]+xhatkp1_p[7]*xhatkp1_p[7]+xhatkp1_p[8]*xhatkp1_p[8]+xhatkp1_p[9]*xhatkp1_p[9]);
  for (int i=0; i<4; i++){
    xhatkp1_p[i+6] = xhatkp1_p[i+6]/quatMag;
  }

  // Predict Covariance


  Serial.println("xhatkp1_p Vector:");
  printArray(&xhatkp1_p[0],10);




  // Run EKF


  // Return Updated State
}
