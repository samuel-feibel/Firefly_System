#include <Arduino.h>

#include <estimateState.h>
#include <IMU_H.h>
#include <GPS_H.h>
#include <math.h>

double r0_ECEF[3];
double NED_C_ECEF[9];
double dhdp;
double alt0;
double p0;

// THIS MAY OR MAY NOT BE NONSENSE. REMAINS TO BE SEEN
static void LatLonAlt2NED_Fcn(double Lat, double Lon, double Alt, double r0_ECEF[3], double NED_C_ECEF[9], double *r_NED)
{
  double t4;
  double t7;
  double t9;
  double t17;
  double t15;
  double t22;

  // LATLONALT2NED_FCN
  //     R_NED = LATLONALT2NED_FCN(LAT,LON,ALT,r0_ECEF,NED_C_ECEF)
  //     This function was generated by the Symbolic Math Toolbox version 8.5.
  //     10-Jun-2021 23:09:47
  t4 = cos(Lat * M_PI / 180.0);
  t7 = Lon * 9.869604401089358 / 32400.0;
  t9 = sin(Lat * 9.869604401089358 / 32400.0);
  t17 = t4 * t4 * 4.0680631590769E+13 + t9 * t9 * 4.0408299984659156E+13;

  t17 = sqrt(t17);
  t15 = 1.0 / t17;
  t17 = Alt + t15 * 4.0680631590769E+13;
  t22 = r0_ECEF[0] + -(t4 * cos(t7) * t17);
  t4 = r0_ECEF[1] + -(t4 * sin(t7) * t17);
  t17 = r0_ECEF[2] + -(t9 * (Alt + t15 * 4.0408299984659148E+13));
  r_NED[0] = (-NED_C_ECEF[0] * t22 - NED_C_ECEF[3] * t4) - NED_C_ECEF[6] * t17;
  r_NED[1] = (-NED_C_ECEF[1] * t22 - NED_C_ECEF[4] * t4) - NED_C_ECEF[7] * t17;
  r_NED[2] = (-NED_C_ECEF[2] * t22 - NED_C_ECEF[5] * t4) - NED_C_ECEF[8] * t17;
}

static void setAngle2Range(double *angle)
{
  if (*angle > M_PI)
  {
    *angle = *angle - 2.0 * M_PI;
  }
}

// Generate Measurement Vector at a point in time
static void getMeasurementVector(double *Z, double *Z_input)
{
  // --- Z_inputs --- //

  // Acceleration
  Z_input[0] = getIMUaccX() * 1E-3 * 9.81;
  Z_input[1] = getIMUaccY() * 1E-3 * 9.81 * -1;
  Z_input[2] = getIMUaccZ() * 1E-3 * 9.81 * -1;

  // Gyro
  Z_input[4] = getIMUgyrX() * M_PI / 180;
  Z_input[5] = getIMUgyrY() * M_PI / 180 * -1;
  Z_input[6] = getIMUgyrZ() * M_PI / 180 * -1;

  // --- Z --- //

  // GPS Position
  double Lat = getGPSLatitude() * 1E-7;
  double Lon = getGPSLongitude() * 1E-7;
  double Alt = getGPSAltitude() * 1E-3;
  double r_NED[3];
  LatLonAlt2NED_Fcn(Lat, Lon, Alt, r0_ECEF, NED_C_ECEF, &r_NED[0]);
  Z[0] = r_NED[0];
  Z[1] = r_NED[1];
  Z[2] = r_NED[2];

  // GPS Speed
  Z[3] = getGPSGroundSpeed();

  // Magnetometer
  Z[4] = getIMUmagX();
  Z[5] = getIMUmagY();
  Z[6] = getIMUmagZ();

  // Heading
  double Heading = getGPSHeading() * M_PI / 180;
  setAngle2Range(&Heading);
  Z[7] = Heading;

  // Altitude
  // pressure = getPressure();
  // double delAlt = (pressure-p0)*dhdp;
  // Z[8] = -delAlt;

  // DEBUG
  // double r_ECEF[3];
  // LatLonAlt2ECEF_Fcn(Lat, Lon, Alt, &r_ECEF[0]);
  // // Serial.print(r_ECEF[0]);
  // // Serial.print(" ");
  // // Serial.print(r_ECEF[1]);
  // // Serial.print(" ");
  // // Serial.println(r_ECEF[2]);
  // Serial.print(r_NED[0]);
  // Serial.print(" ");
  // Serial.print(r_NED[1]);
  // Serial.print(" ");
  // Serial.println(r_NED[2]);
}

// Helper funciton to convert LLA to ECEF
static void LatLonAlt2ECEF_Fcn(double Lat, double Lon, double Alt, double *r_ECEF)
{
  double t2;
  double t3;
  double t4;
  double t5;
  double t11;

  // LATLONALT2ECEF_FCN
  //     R0_ECEF = LATLONALT2ECEF_FCN(LAT,LON,ALT)
  //     This function was generated by the Symbolic Math Toolbox version 8.5.
  //     10-Jun-2021 23:09:53
  t2 = Lat * 3.1415926535897931 / 180.0;
  t3 = Lon * 3.1415926535897931 / 180.0;
  t4 = cos(t2);
  t5 = sin(t2);
  t2 = t4 * t4 * 4.0680631590769E+13 + t5 * t5 * 4.0408299984659156E+13;

  t2 = sqrt(t2);
  t11 = 1.0 / t2;
  t2 = t4 * (Alt + t11 * 4.0680631590769E+13);
  r_ECEF[0] = t2 * cos(t3);
  r_ECEF[1] = t2 * sin(t3);
  r_ECEF[2] = t5 * (Alt + t11 * 4.0408299984659148E+13);
}

// Helper function to generate transformation matrix from ECEF to NED
static void TECEF2NED_Fcn(double r_ECEF[3], double *NED_C_ECEF)
{
  double a;
  double t15;
  double b_a;
  double t13;
  double t12;

  // TECEF2NED_FCN
  //     NED_C_ECEF = TECEF2NED_FCN(r_ECEF)
  //     This function was generated by the Symbolic Math Toolbox version 8.5.
  //     11-Jun-2021 19:40:44
  a = fabs(r_ECEF[0]);
  t15 = fabs(r_ECEF[1]);
  b_a = fabs(r_ECEF[2]);
  t13 = r_ECEF[0] * r_ECEF[0] + r_ECEF[1] * r_ECEF[1];

  t13 = sqrt(t13);
  t12 = 1.0 / t13;
  t13 = (a * a + t15 * t15) + b_a * b_a;
  t15 = 1.0 / sqrt(t13);
  t13 = -(r_ECEF[2] * r_ECEF[2] * (1.0 / t13));

  t13 = sqrt(t13 + 1.0);
  NED_C_ECEF[0] = -r_ECEF[0] * r_ECEF[2] * t12 * t15;
  a = -r_ECEF[1] * t12;
  NED_C_ECEF[1] = a;
  NED_C_ECEF[2] = -r_ECEF[0] * t12 * t13;
  NED_C_ECEF[3] = -r_ECEF[1] * r_ECEF[2] * t12 * t15;
  NED_C_ECEF[4] = r_ECEF[0] * t12;
  NED_C_ECEF[5] = a * t13;
  NED_C_ECEF[6] = t13;
  NED_C_ECEF[7] = 0.0;
  NED_C_ECEF[8] = -r_ECEF[2] * t15;
}

// Sets up R0ECEF and NED_C_ECEF using the first GPS measurement
void setupR0ECEF()
{
  bool initialized = false;
  Serial.print("Setting up r0_ECEF...");
  // while (!initialized)
  while (0) // this is jank delete it
  {
    int SIV = getGPSSIV();

    if (SIV > 2)
    {
      initialized = 1;
      Serial.print(SIV);
      Serial.println(" Sats in view. Success!");
    }
    else
    {
      Serial.print(SIV);
      Serial.println(" Sats in view. Failed.");
      Serial.print("Retrying...");
      delay(500);
    }
  }

  double Lat = getGPSLatitude() * 1E-7;
  double Lon = getGPSLongitude() * 1E-7;
  double Alt = getGPSAltitude() * 1E-3;
  LatLonAlt2ECEF_Fcn(Lat, Lon, Alt, &r0_ECEF[0]);
  TECEF2NED_Fcn(r0_ECEF, &NED_C_ECEF[0]);
  // Serial.print(Lat);
  // Serial.print(" ");
  // Serial.print(Lon);
  // Serial.print(" ");
  // Serial.println(Alt);
  // Serial.print(r0_ECEF[0]);
  // Serial.print(" ");
  // Serial.print(r0_ECEF[1]);
  // Serial.print(" ");
  // Serial.println(r0_ECEF[2]);
}

void setupP0ECEF()
{
  //double pressure = getPressure();
  // dhdp = (-1*1E4/1.2)*1013.25/pressure;
  // alt0 = (-1*1E4/1.2)*log(pressure/1013.25);
  // p0 = pressure;
}

// --- estimateState --- //
void estimateState(double *state)
{
  // Get Measurement vector
  static double Z[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
  static double Z_input[6] = {0, 0, 0, 0, 0, 0};

  getMeasurementVector(&Z[0], &Z_input[0]);
  // Serial.println(state[1]);

  // Run EKF

  // Return Updated State
}
