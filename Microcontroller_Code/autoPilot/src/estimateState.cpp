#include <Arduino.h>
#include <math.h>
#include <utils.h>
#include <estimateState.h>

stateEstimator::stateEstimator(wrapGPS &_myWrapGPS, wrapIMU &_myWrapIMU, wrapBarometer &_mywrapBarometer) : myWrapGPS(_myWrapGPS), myWrapIMU(_myWrapIMU), myWrapBarometer(_mywrapBarometer) {}

void stateEstimator::debug()
{
  Serial.println(r0_ECEF[0]);
}

// THIS MAY OR MAY NOT BE NONSENSE. REMAINS TO BE SEEN
void stateEstimator::LatLonAlt2NED_Fcn(float Lat, float Lon, float Alt, float r0_ECEF[3], float NED_C_ECEF[9], float *r_NED)
{
  float t4;
  float t7;
  float t9;
  float t17;
  float t15;
  float t22;

  // LATLONALT2NED_FCN
  //     R_NED = LATLONALT2NED_FCN(LAT,LON,ALT,r0_ECEF,NED_C_ECEF)
  //     This function was generated by the Symbolic Math Toolbox version 8.5.
  //     10-Jun-2021 23:09:47
  t4 = cos(Lat * M_PI / 180.0);
  t7 = Lon * 9.869604401089358 / 32400.0;
  t9 = sin(Lat * 9.869604401089358 / 32400.0);
  t17 = t4 * t4 * 4.0680631590769E+13 + t9 * t9 * 4.0408299984659156E+13;

  t17 = sqrt(t17);
  t15 = 1.0 / t17;
  t17 = Alt + t15 * 4.0680631590769E+13;
  t22 = r0_ECEF[0] + -(t4 * cos(t7) * t17);
  t4 = r0_ECEF[1] + -(t4 * sin(t7) * t17);
  t17 = r0_ECEF[2] + -(t9 * (Alt + t15 * 4.0408299984659148E+13));
  r_NED[0] = (-NED_C_ECEF[0] * t22 - NED_C_ECEF[3] * t4) - NED_C_ECEF[6] * t17;
  r_NED[1] = (-NED_C_ECEF[1] * t22 - NED_C_ECEF[4] * t4) - NED_C_ECEF[7] * t17;
  r_NED[2] = (-NED_C_ECEF[2] * t22 - NED_C_ECEF[5] * t4) - NED_C_ECEF[8] * t17;
}

void stateEstimator::setAngle2Range(float *angle)
{

  if (*angle > M_PI)
  {
    *angle = *angle - 2.0 * M_PI;
  }
}

// Generate Measurement Vector at a point in time
void stateEstimator::getMeasurementVector(float *Z, float *Z_input)
{
  // --- Z_inputs --- //

  // Acceleration
  Z_input[0] = myWrapIMU.getaccX() * 1E-3 * 9.81;
  Z_input[1] = myWrapIMU.getaccY() * 1E-3 * 9.81 * -1;
  Z_input[2] = myWrapIMU.getaccZ() * 1E-3 * 9.81 * -1;

  // Gyro
  Z_input[4] = myWrapIMU.getgyrX() * M_PI / 180;
  Z_input[5] = myWrapIMU.getgyrY() * M_PI / 180 * -1;
  Z_input[6] = myWrapIMU.getgyrZ() * M_PI / 180 * -1;

  // --- Z --- //

  // GPS Position
  float Lat = myWrapGPS.getLatitude() * 1E-7;
  float Lon = myWrapGPS.getLongitude() * 1E-7;
  float Alt = myWrapGPS.getAltitude() * 1E-3;
  float r_NED[3];
  LatLonAlt2NED_Fcn(Lat, Lon, Alt, r0_ECEF, NED_C_ECEF, &r_NED[0]);
  Z[0] = r_NED[0];
  Z[1] = r_NED[1];
  Z[2] = r_NED[2];

  // GPS Speed
  Z[3] = myWrapGPS.getGroundSpeed();

  // Magnetometer
  Z[4] = myWrapIMU.getmagX();
  Z[5] = myWrapIMU.getmagY();
  Z[6] = myWrapIMU.getmagZ();

  // Heading
  float Heading = myWrapGPS.getHeading() * 1E-5 * M_PI / 180;
  setAngle2Range(&Heading);
  Z[7] = Heading;

  // Altitude
  float pressure = myWrapBarometer.getPressure();
  float delAlt = (pressure - p0) * dhdp;
  Z[8] = -delAlt;
}

// Helper funciton to convert LLA to ECEF
void stateEstimator::LatLonAlt2ECEF_Fcn(float Lat, float Lon, float Alt, float *r_ECEF)
{
  float t2;
  float t3;
  float t4;
  float t5;
  float t11;

  // LATLONALT2ECEF_FCN
  //     R0_ECEF = LATLONALT2ECEF_FCN(LAT,LON,ALT)
  //     This function was generated by the Symbolic Math Toolbox version 8.5.
  //     10-Jun-2021 23:09:53
  t2 = Lat * 3.1415926535897931 / 180.0;
  t3 = Lon * 3.1415926535897931 / 180.0;
  t4 = cos(t2);
  t5 = sin(t2);
  t2 = t4 * t4 * 4.0680631590769E+13 + t5 * t5 * 4.0408299984659156E+13;

  t2 = sqrt(t2);
  t11 = 1.0 / t2;
  t2 = t4 * (Alt + t11 * 4.0680631590769E+13);
  r_ECEF[0] = t2 * cos(t3);
  r_ECEF[1] = t2 * sin(t3);
  r_ECEF[2] = t5 * (Alt + t11 * 4.0408299984659148E+13);
}

// Helper function to generate transformation matrix from ECEF to NED
void stateEstimator::TECEF2NED_Fcn(float r_ECEF[3], float *NED_C_ECEF)
{
  float a;
  float t15;
  float b_a;
  float t13;
  float t12;

  // TECEF2NED_FCN
  //     NED_C_ECEF = TECEF2NED_FCN(r_ECEF)
  //     This function was generated by the Symbolic Math Toolbox version 8.5.
  //     11-Jun-2021 19:40:44
  a = fabs(r_ECEF[0]);
  t15 = fabs(r_ECEF[1]);
  b_a = fabs(r_ECEF[2]);
  t13 = r_ECEF[0] * r_ECEF[0] + r_ECEF[1] * r_ECEF[1];

  t13 = sqrt(t13);
  t12 = 1.0 / t13;
  t13 = (a * a + t15 * t15) + b_a * b_a;
  t15 = 1.0 / sqrt(t13);
  t13 = -(r_ECEF[2] * r_ECEF[2] * (1.0 / t13));

  t13 = sqrt(t13 + 1.0);
  NED_C_ECEF[0] = -r_ECEF[0] * r_ECEF[2] * t12 * t15;
  a = -r_ECEF[1] * t12;
  NED_C_ECEF[1] = a;
  NED_C_ECEF[2] = -r_ECEF[0] * t12 * t13;
  NED_C_ECEF[3] = -r_ECEF[1] * r_ECEF[2] * t12 * t15;
  NED_C_ECEF[4] = r_ECEF[0] * t12;
  NED_C_ECEF[5] = a * t13;
  NED_C_ECEF[6] = t13;
  NED_C_ECEF[7] = 0.0;
  NED_C_ECEF[8] = -r_ECEF[2] * t15;
}

// Continuous Dynamics Function
void stateEstimator::f_Fcn(float *xhatk_u, float *uk, float *fdot)
{
  float t2;
  float t3;
  float t4;
  float t5;
  float t6;
  float t7_tmp;
  float t7;
  float t8_tmp;
  float t8;
  float t9_tmp;
  float t9;
  float t10_tmp;
  float t10;
  float t11;

  // F_FCN
  //     F = F_FCN(T,xhatk_u,uk)
  //     This function was generated by the Symbolic Math Toolbox version 8.5.
  //     16-Aug-2021 15:17:55
  t2 = xhatk_u[6] * xhatk_u[6];
  t3 = xhatk_u[7] * xhatk_u[7];
  t4 = xhatk_u[8] * xhatk_u[8];
  t5 = xhatk_u[9] * xhatk_u[9];
  t6 = xhatk_u[6] * xhatk_u[7] * 2.0;
  t7_tmp = xhatk_u[6] * xhatk_u[8];
  t7 = t7_tmp * 2.0;
  t8_tmp = xhatk_u[6] * xhatk_u[9];
  t8 = t8_tmp * 2.0;
  t9_tmp = xhatk_u[7] * xhatk_u[8];
  t9 = t9_tmp * 2.0;
  t10_tmp = xhatk_u[7] * xhatk_u[9];
  t10 = t10_tmp * 2.0;
  t11 = xhatk_u[8] * xhatk_u[9] * 2.0;
  fdot[0] = (xhatk_u[3] * (((t2 + t5) + -t3) + -t4) + xhatk_u[5] * (t7 + t10)) + xhatk_u[4] *
                                                                                     (t6 - t11);
  fdot[1] = (-xhatk_u[4] * (((t2 + t4) + -t3) + -t5) + xhatk_u[3] * (t6 + t11)) - xhatk_u[5] *
                                                                                      (t8 - t9);
  fdot[2] = (-xhatk_u[5] * (((t2 + t3) + -t4) + -t5) + xhatk_u[4] * (t8 + t9)) + xhatk_u[3] *
                                                                                     (t7 - t10);
  fdot[3] = (uk[0] + t7_tmp * 19.6) - t10_tmp * 19.6;
  fdot[4] = (uk[1] + t8_tmp * 19.6) + t9_tmp * 19.6;
  fdot[5] = (((uk[2] - t2 * 9.8) - t3 * 9.8) + t4 * 9.8) + t5 * 9.8;
  fdot[6] = (uk[3] * xhatk_u[9] / 2.0 - uk[4] * xhatk_u[8] / 2.0) + xhatk_u[7] * uk[5] / 2.0;
  fdot[7] = (uk[3] * xhatk_u[8] / 2.0 + uk[4] * xhatk_u[9] / 2.0) - xhatk_u[6] * uk[5] / 2.0;
  fdot[8] = (uk[3] * xhatk_u[7] * -0.5 + uk[4] * xhatk_u[6] / 2.0) + xhatk_u[9] * uk[5] /
                                                                         2.0;
  fdot[9] = (uk[3] * xhatk_u[6] * -0.5 - uk[4] * xhatk_u[7] / 2.0) - xhatk_u[8] * uk[5] /
                                                                         2.0;
}

// Predict State
void stateEstimator::predictState(float delt, float *xhatk_u, float *uk, float *xhatkp1_p)
{
  float fdot[10];
  f_Fcn(&xhatk_u[0], &uk[0], &fdot[0]);

  for (int i = 0; i < 10; i++)
  {
    xhatkp1_p[i] = xhatk_u[i] + delt * fdot[i];
  }
}

// Sets up R0ECEF and NED_C_ECEF using the first GPS measurement
void stateEstimator::setupR0ECEF()
{
  bool initialized = false;
  Serial.print("Setting up r0_ECEF ... ");
  while (!initialized)
  // while (0) // this is jank delete it
  {
    myWrapGPS.update();
    int SIV = myWrapGPS.getSIV();

    if (SIV > 2)
    {
      initialized = 1;
      Serial.print(SIV);
      Serial.println(" Sats in view. Success!");
    }
    else
    {
      Serial.print(SIV);
      Serial.println(" Sats in view. Failed.");
      Serial.print("Retrying...");
      delay(500);
    }
  }

  float Lat = myWrapGPS.getLatitude() * 1E-7;
  float Lon = myWrapGPS.getLongitude() * 1E-7;
  float Alt = myWrapGPS.getAltitude() * 1E-3;
  LatLonAlt2ECEF_Fcn(Lat, Lon, Alt, &r0_ECEF[0]);
  TECEF2NED_Fcn(r0_ECEF, &NED_C_ECEF[0]);
}

void stateEstimator::setupP0()
{
  bool initialized = false;
  float pressure;
  Serial.print("Setting up p0...");
  while (!initialized)
  {
    myWrapBarometer.update();
    pressure = myWrapBarometer.getPressure();

    if (pressure != -1)
    {
      initialized = 1;
      Serial.println(" Success!");
    }
    else
    {
      delay(50);
    }
  }

  dhdp = (-1.0 / 1.2E-4) * 1.0 / pressure;
  alt0 = (-1.0 / 1.2E-4) * log(pressure / 1013.25);
  p0 = pressure;
}

// --- estimateState --- //
void stateEstimator::step(float *xhatk_u, float delt)
{

  // Get Measurement vector
  static float Z[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
  static float Z_input[6] = {0, 0, 0, 0, 0, 0};
  getMeasurementVector(&Z[0], &Z_input[0]);

  // Serial.println("Measurement Vector:");
  // printArray(&Z[0],9);

  // Predict State
  float xhatkp1_p[10];
  predictState(delt, &xhatk_u[0], &Z_input[0], &xhatkp1_p[0]);

  // Normalize Quaternion
  float quatMag = sqrt(xhatkp1_p[6] * xhatkp1_p[6] + xhatkp1_p[7] * xhatkp1_p[7] + xhatkp1_p[8] * xhatkp1_p[8] + xhatkp1_p[9] * xhatkp1_p[9]);
  for (int i = 0; i < 4; i++)
  {
    xhatkp1_p[i + 6] = xhatkp1_p[i + 6] / quatMag;
  }

  // Predict Covariance

  Serial.println("xhatkp1_p Vector:");
  printArray(&xhatkp1_p[0], 10);

  // Run EKF

  // Return Updated State
}
