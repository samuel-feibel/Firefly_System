#include <Arduino.h>
#include <math.h>
#include <utils.h>
#include <estimateState.h>


stateEstimator::stateEstimator(wrapGPS &_myWrapGPS, wrapIMU &_myWrapIMU, wrapBarometer &_mywrapBarometer) : myWrapGPS(_myWrapGPS), myWrapIMU(_myWrapIMU), myWrapBarometer(_mywrapBarometer) {}

void stateEstimator::debug()
{
}

// THIS MAY OR MAY NOT BE NONSENSE. REMAINS TO BE SEEN
void stateEstimator::LatLonAlt2NED_Fcn(float Lat, float Lon, float Alt, float r0_ECEF[3], float NED_C_ECEF[9], float *r_NED)
{
  float t4;
  float t7;
  float t9;
  float t17;
  float t15;
  float t22;

  // LATLONALT2NED_FCN
  //     R_NED = LATLONALT2NED_FCN(LAT,LON,ALT,r0_ECEF,NED_C_ECEF)
  //     This function was generated by the Symbolic Math Toolbox version 8.5.
  //     10-Jun-2021 23:09:47
  t4 = cos(Lat * M_PI / 180.0);
  t7 = Lon * 9.869604401089358 / 32400.0;
  t9 = sin(Lat * 9.869604401089358 / 32400.0);
  t17 = t4 * t4 * 4.0680631590769E+13 + t9 * t9 * 4.0408299984659156E+13;

  t17 = sqrt(t17);
  t15 = 1.0 / t17;
  t17 = Alt + t15 * 4.0680631590769E+13;
  t22 = r0_ECEF[0] + -(t4 * cos(t7) * t17);
  t4 = r0_ECEF[1] + -(t4 * sin(t7) * t17);
  t17 = r0_ECEF[2] + -(t9 * (Alt + t15 * 4.0408299984659148E+13));
  r_NED[0] = (-NED_C_ECEF[0] * t22 - NED_C_ECEF[3] * t4) - NED_C_ECEF[6] * t17;
  r_NED[1] = (-NED_C_ECEF[1] * t22 - NED_C_ECEF[4] * t4) - NED_C_ECEF[7] * t17;
  r_NED[2] = (-NED_C_ECEF[2] * t22 - NED_C_ECEF[5] * t4) - NED_C_ECEF[8] * t17;
}

void stateEstimator::setAngle2Range(float *angle)
{

  if (*angle > M_PI)
  {
    *angle = *angle - 2.0 * M_PI;
  }
}

// Generate Measurement Vector at a point in time
void stateEstimator::getMeasurementVector(float *Z, float *Z_input)
{
  // --- Z_inputs --- //

  // Acceleration
  Z_input[0] = myWrapIMU.getaccX() * 1E-3 * 9.81;
  Z_input[1] = myWrapIMU.getaccY() * 1E-3 * 9.81 * -1;
  Z_input[2] = myWrapIMU.getaccZ() * 1E-3 * 9.81 * -1;

  // Gyro
  Z_input[4] = myWrapIMU.getgyrX() * M_PI / 180;
  Z_input[5] = myWrapIMU.getgyrY() * M_PI / 180 * -1;
  Z_input[6] = myWrapIMU.getgyrZ() * M_PI / 180 * -1;

  // --- Z --- //

  // GPS Position
  float Lat = myWrapGPS.getLatitude() * 1E-7;
  float Lon = myWrapGPS.getLongitude() * 1E-7;
  float Alt = myWrapGPS.getAltitude() * 1E-3;
  float r_NED[3];
  LatLonAlt2NED_Fcn(Lat, Lon, Alt, r0_ECEF, NED_C_ECEF, &r_NED[0]);
  Z[0] = r_NED[0];
  Z[1] = r_NED[1];
  Z[2] = r_NED[2];

  // GPS Speed
  Z[3] = myWrapGPS.getGroundSpeed();

  // Magnetometer
  Z[4] = myWrapIMU.getmagX();
  Z[5] = myWrapIMU.getmagY();
  Z[6] = myWrapIMU.getmagZ();

  // Heading
  float Heading = myWrapGPS.getHeading() * 1E-5 * M_PI / 180;
  setAngle2Range(&Heading);
  Z[7] = Heading;

  // Altitude
  float pressure = myWrapBarometer.getPressure();
  float delAlt = (pressure - p0) * dhdp;
  Z[8] = -delAlt;
}

// Helper funciton to convert LLA to ECEF
void stateEstimator::LatLonAlt2ECEF_Fcn(float Lat, float Lon, float Alt, float *r_ECEF)
{
  float t2;
  float t3;
  float t4;
  float t5;
  float t11;

  // LATLONALT2ECEF_FCN
  //     R0_ECEF = LATLONALT2ECEF_FCN(LAT,LON,ALT)
  //     This function was generated by the Symbolic Math Toolbox version 8.5.
  //     10-Jun-2021 23:09:53
  t2 = Lat * 3.1415926535897931 / 180.0;
  t3 = Lon * 3.1415926535897931 / 180.0;
  t4 = cos(t2);
  t5 = sin(t2);
  t2 = t4 * t4 * 4.0680631590769E+13 + t5 * t5 * 4.0408299984659156E+13;

  t2 = sqrt(t2);
  t11 = 1.0 / t2;
  t2 = t4 * (Alt + t11 * 4.0680631590769E+13);
  r_ECEF[0] = t2 * cos(t3);
  r_ECEF[1] = t2 * sin(t3);
  r_ECEF[2] = t5 * (Alt + t11 * 4.0408299984659148E+13);
}

// Helper function to generate transformation matrix from ECEF to NED
void stateEstimator::TECEF2NED_Fcn(float r_ECEF[3], float *NED_C_ECEF)
{
  float a;
  float t15;
  float b_a;
  float t13;
  float t12;

  // TECEF2NED_FCN
  //     NED_C_ECEF = TECEF2NED_FCN(r_ECEF)
  //     This function was generated by the Symbolic Math Toolbox version 8.5.
  //     11-Jun-2021 19:40:44
  a = fabs(r_ECEF[0]);
  t15 = fabs(r_ECEF[1]);
  b_a = fabs(r_ECEF[2]);
  t13 = r_ECEF[0] * r_ECEF[0] + r_ECEF[1] * r_ECEF[1];

  t13 = sqrt(t13);
  t12 = 1.0 / t13;
  t13 = (a * a + t15 * t15) + b_a * b_a;
  t15 = 1.0 / sqrt(t13);
  t13 = -(r_ECEF[2] * r_ECEF[2] * (1.0 / t13));

  t13 = sqrt(t13 + 1.0);
  NED_C_ECEF[0] = -r_ECEF[0] * r_ECEF[2] * t12 * t15;
  a = -r_ECEF[1] * t12;
  NED_C_ECEF[1] = a;
  NED_C_ECEF[2] = -r_ECEF[0] * t12 * t13;
  NED_C_ECEF[3] = -r_ECEF[1] * r_ECEF[2] * t12 * t15;
  NED_C_ECEF[4] = r_ECEF[0] * t12;
  NED_C_ECEF[5] = a * t13;
  NED_C_ECEF[6] = t13;
  NED_C_ECEF[7] = 0.0;
  NED_C_ECEF[8] = -r_ECEF[2] * t15;
}

// Continuous Dynamics Function
void stateEstimator::f_Fcn(float *xhatk_u, float *uk, float *fdot)
{
  float t2;
  float t3;
  float t4;
  float t5;
  float t6;
  float t7_tmp;
  float t7;
  float t8_tmp;
  float t8;
  float t9_tmp;
  float t9;
  float t10_tmp;
  float t10;
  float t11;

  // F_FCN
  //     F = F_FCN(T,xhatk_u,uk)
  //     This function was generated by the Symbolic Math Toolbox version 8.5.
  //     16-Aug-2021 15:17:55
  t2 = xhatk_u[6] * xhatk_u[6];
  t3 = xhatk_u[7] * xhatk_u[7];
  t4 = xhatk_u[8] * xhatk_u[8];
  t5 = xhatk_u[9] * xhatk_u[9];
  t6 = xhatk_u[6] * xhatk_u[7] * 2.0;
  t7_tmp = xhatk_u[6] * xhatk_u[8];
  t7 = t7_tmp * 2.0;
  t8_tmp = xhatk_u[6] * xhatk_u[9];
  t8 = t8_tmp * 2.0;
  t9_tmp = xhatk_u[7] * xhatk_u[8];
  t9 = t9_tmp * 2.0;
  t10_tmp = xhatk_u[7] * xhatk_u[9];
  t10 = t10_tmp * 2.0;
  t11 = xhatk_u[8] * xhatk_u[9] * 2.0;
  fdot[0] = (xhatk_u[3] * (((t2 + t5) + -t3) + -t4) + xhatk_u[5] * (t7 + t10)) + xhatk_u[4] *
                                                                                     (t6 - t11);
  fdot[1] = (-xhatk_u[4] * (((t2 + t4) + -t3) + -t5) + xhatk_u[3] * (t6 + t11)) - xhatk_u[5] *
                                                                                      (t8 - t9);
  fdot[2] = (-xhatk_u[5] * (((t2 + t3) + -t4) + -t5) + xhatk_u[4] * (t8 + t9)) + xhatk_u[3] *
                                                                                     (t7 - t10);
  fdot[3] = (uk[0] + t7_tmp * 19.6) - t10_tmp * 19.6;
  fdot[4] = (uk[1] + t8_tmp * 19.6) + t9_tmp * 19.6;
  fdot[5] = (((uk[2] - t2 * 9.8) - t3 * 9.8) + t4 * 9.8) + t5 * 9.8;
  fdot[6] = (uk[3] * xhatk_u[9] / 2.0 - uk[4] * xhatk_u[8] / 2.0) + xhatk_u[7] * uk[5] / 2.0;
  fdot[7] = (uk[3] * xhatk_u[8] / 2.0 + uk[4] * xhatk_u[9] / 2.0) - xhatk_u[6] * uk[5] / 2.0;
  fdot[8] = (uk[3] * xhatk_u[7] * -0.5 + uk[4] * xhatk_u[6] / 2.0) + xhatk_u[9] * uk[5] /
                                                                         2.0;
  fdot[9] = (uk[3] * xhatk_u[6] * -0.5 - uk[4] * xhatk_u[7] / 2.0) - xhatk_u[8] * uk[5] /
                                                                         2.0;
}

// Continuous F Function
// // Function Definitions
// void F_jac_Fcn(const float xhatk_u[10], const float in2[6], float F[100])
// {
//   float t2;
//   float t3;
//   float t4;
//   float t5;
//   float t6;
//   float t7;
//   float t8;
//   float t9;
//   float t10;
//   float t11;
//   float t13;
//   float t14;
//   float t15;
//   float t16;
//   float t18;
//   float t19;
//   float t20;
//   float t21;
//   float t23;
//   float t27;
//   float t28;
//   float t29;
//   float t36;
//   float t37;
//   float t38;
//   float t39;
//   float t41;
//   float t42;
//   float t43;
//   float t44;

//   // F_JAC_FCN
//   //     F = F_JAC_FCN(xhatk_u,IN2)
//   //     This function was generated by the Symbolic Math Toolbox version 8.5.
//   //     23-Jul-2021 11:41:29
//   t2 = xhatk_u[6] * xhatk_u[6];
//   t3 = xhatk_u[7] * xhatk_u[7];
//   t4 = xhatk_u[8] * xhatk_u[8];
//   t5 = xhatk_u[9] * xhatk_u[9];
//   t6 = xhatk_u[6] * xhatk_u[7] * 2.0;
//   t7 = xhatk_u[6] * xhatk_u[8] * 2.0;
//   t8 = xhatk_u[6] * xhatk_u[9] * 2.0;
//   t9 = xhatk_u[7] * xhatk_u[8] * 2.0;
//   t10 = xhatk_u[7] * xhatk_u[9] * 2.0;
//   t11 = xhatk_u[8] * xhatk_u[9] * 2.0;
//   t13 = xhatk_u[7] * xhatk_u[3] * 2.0;
//   t14 = xhatk_u[8] * xhatk_u[3] * 2.0;
//   t15 = xhatk_u[9] * xhatk_u[3] * 2.0;
//   t16 = xhatk_u[6] * xhatk_u[4] * 2.0;
//   t18 = xhatk_u[8] * xhatk_u[4] * 2.0;
//   t19 = xhatk_u[9] * xhatk_u[4] * 2.0;
//   t20 = xhatk_u[6] * xhatk_u[5] * 2.0;
//   t21 = xhatk_u[7] * xhatk_u[5] * 2.0;
//   t23 = xhatk_u[9] * xhatk_u[5] * 2.0;
//   t27 = in2[3] / 2.0;
//   t28 = in2[4] / 2.0;
//   t29 = in2[5] / 2.0;
//   t36 = xhatk_u[6] * 19.6;
//   t37 = xhatk_u[7] * 19.6;
//   t38 = xhatk_u[8] * 19.6;
//   t39 = xhatk_u[9] * 19.6;
//   t41 = (xhatk_u[6] * xhatk_u[3] * 2.0 + xhatk_u[7] * xhatk_u[4] * 2.0) + xhatk_u[8] * xhatk_u[5] * 2.0;
//   t42 = (t16 + t23) + -t13;
//   t43 = (t14 + t19) + -t20;
//   t44 = (t15 + t21) + -t18;
//   memset(&F[0], 0, 30U * sizeof(float));
//   F[30] = ((t2 + t5) + -t3) + -t4;
//   F[31] = t6 + t11;
//   F[32] = t7 - t10;
//   F[33] = 0.0;
//   F[34] = 0.0;
//   F[35] = 0.0;
//   F[36] = 0.0;
//   F[37] = 0.0;
//   F[38] = 0.0;
//   F[39] = 0.0;
//   F[40] = t6 - t11;
//   F[41] = ((t3 + t5) + -t2) + -t4;
//   F[42] = t8 + t9;
//   F[43] = 0.0;
//   F[44] = 0.0;
//   F[45] = 0.0;
//   F[46] = 0.0;
//   F[47] = 0.0;
//   F[48] = 0.0;
//   F[49] = 0.0;
//   F[50] = t7 + t10;
//   F[51] = -t8 + t9;
//   F[52] = ((t4 + t5) + -t2) + -t3;
//   F[53] = 0.0;
//   F[54] = 0.0;
//   F[55] = 0.0;
//   F[56] = 0.0;
//   F[57] = 0.0;
//   F[58] = 0.0;
//   F[59] = 0.0;
//   F[60] = t41;
//   F[61] = (t13 - t16) - t23;
//   F[62] = t43;
//   F[63] = t38;
//   F[64] = t39;
//   F[65] = -t36;
//   F[66] = 0.0;
//   F[67] = -t29;
//   F[68] = t28;
//   F[69] = -t27;
//   F[70] = t42;
//   F[71] = t41;
//   F[72] = (-t15 + t18) - t21;
//   F[73] = -t39;
//   F[74] = t38;
//   F[75] = -t37;
//   F[76] = t29;
//   F[77] = 0.0;
//   F[78] = -t27;
//   F[79] = -t28;
//   F[80] = (-t14 - t19) + t20;
//   F[81] = t44;
//   F[82] = t41;
//   F[83] = t36;
//   F[84] = t37;
//   F[85] = t38;
//   F[86] = -t28;
//   F[87] = t27;
//   F[88] = 0.0;
//   F[89] = -t29;
//   F[90] = t44;
//   F[91] = t43;
//   F[92] = t42;
//   F[93] = -t37;
//   F[94] = t36;
//   F[95] = t39;
//   F[96] = t27;
//   F[97] = t28;
//   F[98] = t29;
//   F[99] = 0.0;
// }

// Predict State
void stateEstimator::predictState(float delt, float *xhatk_u, float *uk, Matrix<Ns> &xhatkp1_p)
{
  float fdot[10];
  f_Fcn(&xhatk_u[0], &uk[0], &fdot[0]);

  for (int i = 0; i < 10; i++)
  {
    xhatkp1_p(i) = xhatk_u[i] + delt * fdot[i];
  }
}

// Sets up R0ECEF and NED_C_ECEF using the first GPS measurement
void stateEstimator::setupR0ECEF()
{
  bool initialized = false;
  Serial.print("Setting up r0_ECEF ... ");
  while (!initialized)
  // while (0) // this is jank delete it
  {
    myWrapGPS.update();
    int SIV = myWrapGPS.getSIV();

    if (SIV > 2)
    {
      initialized = 1;
      Serial.print(SIV);
      Serial.println(" Sats in view. Success!");
    }
    else
    {
      Serial.print(SIV);
      Serial.println(" Sats in view. Failed.");
      Serial.print("Retrying...");
      delay(500);
    }
  }

  float Lat = myWrapGPS.getLatitude() * 1E-7;
  float Lon = myWrapGPS.getLongitude() * 1E-7;
  float Alt = myWrapGPS.getAltitude() * 1E-3;
  LatLonAlt2ECEF_Fcn(Lat, Lon, Alt, r0_ECEF);
  TECEF2NED_Fcn(r0_ECEF, NED_C_ECEF);
}

void stateEstimator::setupP0()
{
  bool initialized = false;
  float pressure;
  Serial.print("Setting up p0...");
  while (!initialized)
  {
    myWrapBarometer.update();
    pressure = myWrapBarometer.getPressure();

    if (pressure != -1)
    {
      initialized = 1;
      Serial.println(" Success!");
    }
    else
    {
      delay(50);
    }
  }

  dhdp = (-1.0 / 1.2E-4) * 1.0 / pressure;
  alt0 = (-1.0 / 1.2E-4) * log(pressure / 1013.25);
  p0 = pressure;
}

// --- estimateState --- //
void stateEstimator::step(float *xhatk_u, float delt)
{

  // Get Measurement vector
  static float Z[9] = {0, 0, 0, 0, 0, 0, 0, 0, 0};
  static float Z_input[6] = {0, 0, 0, 0, 0, 0};
  getMeasurementVector(&Z[0], &Z_input[0]);

  // Serial.println("Measurement Vector:");
  // printArray(&Z[0],9);

  // Predict State
  Matrix<Ns> xhatkp1_p;
  predictState(delt, &xhatk_u[0], &Z_input[0], xhatkp1_p);

  // Normalize Quaternion
  // float quatMag = sqrt(xhatkp1_p(6) * xhatkp1_p(6) + xhatkp1_p(7) * xhatkp1_p(7) + xhatkp1_p(8] * xhatkp1_p[8] + xhatkp1_p[9] * xhatkp1_p[9]);
  // for (int i = 0; i < 4; i++)
  // {
  //   xhatkp1_p[i + 6] = xhatkp1_p[i + 6] / quatMag;
  // }

  // Predict Covariance

  // Serial.println("xhatkp1_p Vector:");
  // printArray(&xhatkp1_p[0], 10);

  // Run EKF

  // Return Updated State

}
